b'#!/usr/bin/env python\r\n# -*- coding: utf-8 -*-\r\n\r\n# A Python script that experiments with programming paradigms and ideas.\r\n# by R.J. Guill\xc3\xa9n (rjguillen [at] qaczar.com) 2022\r\n\r\n#   GUIDELINES\r\n# - Keep the line width to less than 100 characters.\r\n# - Use functions, not classes, for modularity, composability and encapsulation.\r\n# - Functions should not reference functions or globals from later in the script.\r\n# - TODO items should be encapsulated in functions to simplify refactoring.\r\n# - Avoid using asynchrony, concurrency, multiprocessing, multithreading, etc. Use HTTPS for RPC.\r\n# - Use the standard library, not third-party libraries. Seriously.\r\n# - Sometimes its ok to break the rules, take advantage of the language.\r\n# - In case of doubt, just run the script and see what happens.\r\n\r\n\r\n#@# LOCAL PLATFORM\r\n\r\nimport os\r\nimport sys\r\nimport time\r\nimport typing as t\r\n\r\nPYTHON = sys.executable\r\nPID = os.getpid()\r\n\r\ndef iso8601() -> str: \r\n    return time.strftime(\'%Y-%m-%d %H:%M:%S\', time.gmtime())\r\n\r\ndef emit(msg: str, _at=None) -> None: \r\n    global PID\r\n    frame = _at or sys._getframe(1)  \r\n    print(f\'[{PID}:{frame.f_lineno} {iso8601()}] {frame.f_code.co_name}:  {msg}\', file=sys.stderr)\r\n\r\ndef halt(msg: str) -> t.NoReturn:\r\n    frame = sys._getframe(1)\r\n    emit(f"{msg} <- Final message.", _at=frame)\r\n    emit(f"Halting all processes.", _at=frame)\r\n    sys.exit(0)\r\n\r\ndef mtime_file(fname: str) -> float:\r\n    if not os.path.isfile(fname): return 0.0\r\n    return os.path.getmtime(fname)\r\n\r\ndef read_file(fname: str, encoding=None) -> bytes:\r\n    if \'__\' in fname: fname = fname.replace(\'__\', \'.\')\r\n    with open(fname, \'rb\' if not encoding else \'r\', encoding=encoding) as f: return f.read()\r\n    \r\ndef write_file(fname: str, data: bytes | str, encoding=None) -> None:\r\n    if encoding and not isinstance(data, str): data = str(data)\r\n    if \'__\' in fname: fname = fname.replace(\'__\', \'.\')\r\n    if not os.path.isdir(os.path.dirname(fname)): os.makedirs(os.path.dirname(fname))\r\n    with open(fname, \'wb\' if not encoding else \'w\', encoding=encoding) as f: f.write(data)\r\n\r\n\r\n#@# META-PROGRAMMING\r\n\r\nimport importlib\r\nimport functools\r\n\r\nDEBUG = False\r\n\r\ndef dedent(code: str) -> str:\r\n    indent = len(code) - len(code.lstrip()) - 1\r\n    return \'\\n\'.join(line[indent:] for line in code.splitlines())\r\n\r\ndef timed(f: t.Callable) -> t.Callable:\r\n    global DEBUG\r\n    if not DEBUG: return f\r\n    @functools.wraps(f)\r\n    def timed(*args, **kwargs):\r\n        start = time.time(); elapsed = time.time() - start\r\n        emit(f"Function <{f.__name__}> {args=} {kwargs=} called.")\r\n        result = f(*args, **kwargs)\r\n        emit(f"Function <{f.__name__}> {args=} {kwargs=} took {elapsed:.4f} seconds.")\r\n        return result\r\n    return timed\r\n\r\nREQUIREMENTS = set()\r\n\r\ndef pip_import(module: str) -> t.Any:\r\n    global REQUIREMENTS\r\n    name = module.split(\'.\')[0]\r\n    if name not in REQUIREMENTS:    \r\n        subprocess.run([sys.executable, \'-m\', \'pip\', \'install\', name])\r\n        REQUIREMENTS.add(name)\r\n    return importlib.import_module(module)\r\n\r\ndef imports(*modules: tuple[str]) -> t.Callable:\r\n    def decorator(f):\r\n        @functools.wraps(f)\r\n        def wrapper(*args, **kwargs):\r\n            imported = [pip_import(module) for module in modules]\r\n            emit(f"Imported {modules=} for {f.__name__}.")\r\n            return f(*imported, *args, **kwargs)\r\n        return wrapper\r\n    return decorator\r\n\r\ndef extract_code(fname: str, **filters) -> str:\r\n    # TODO: Implement filters.\r\n    code = read_file(fname, encoding=\'utf-8\')\r\n    return code\r\n\r\n\r\n#@# SUBPROCESSING\r\n\r\nimport shutil\r\nimport atexit\r\nimport subprocess \r\n\r\ndef arg_line(*args: tuple[str], **kwargs: dict) -> tuple[str]:\r\n    for k, v in kwargs.items(): args += (f\'--{k}={str(v)}\', )\r\n    return args\r\n\r\ndef split_arg_line(args: list[str]) -> tuple[tuple, dict]:\r\n    largs, kwargs = [], {}\r\n    for arg in args:\r\n        if \'=\' in arg: \r\n            __key, __value = arg[2:].split(\'=\'); kwargs[__key] = __value\r\n        else: largs.append(arg)\r\n    return tuple(largs), kwargs\r\n\r\ndef setup_environ(reset=False) -> None:\r\n    global PYTHON\r\n    if reset and os.path.isdir(\'.venv\'):\r\n        emit(f"Removing {\'.venv\'} directory.")\r\n        shutil.rmtree(\'.venv\')\r\n    if sys.platform.startswith(\'win\'):\r\n        if not os.path.isfile(\'.venv/Scripts/python.exe\'): \r\n            subprocess.run([sys.executable, \'-m\', \'venv\', \'.venv\'])\r\n        PYTHON = \'.venv/Scripts/python.exe\'\r\n    elif not os.path.isfile(\'.venv/bin/python3\'): \r\n        subprocess.run([sys.executable, \'-m\', \'venv\', \'.venv\'])\r\n        PYTHON = \'.venv/bin/python3\'\r\n    subprocess.run([PYTHON, \'-m\', \'pip\', \'install\', \'--upgrade\', \'pip\'])\r\n\r\ndef start_py(script: str, *args: list[str], **kwargs: dict) -> subprocess.Popen:\r\n    global PYTHON\r\n    line_args = [str(a) for a in arg_line(*args, **kwargs)]\r\n    emit(f"Starting {script=} {line_args=}.")\r\n    # Popen is a context manager, but we want to keep proc alive and not wait for it.\r\n    # We cannot use run() for this. Remember to manually terminate the process later.\r\n    proc = subprocess.Popen([PYTHON, script, *line_args],\r\n                            stdout=sys.stdout, stderr=sys.stderr)\r\n    proc._args, proc._kwargs = args, kwargs  # Magic for restart_python.\r\n    atexit.register(proc.terminate)\r\n    emit(f"Started script=\'{os.path.basename(script)}\' {proc.pid=}.")\r\n    return proc\r\n\r\ndef stop_py(proc: subprocess.Popen) -> tuple[tuple, dict]:\r\n    emit(f"Stopping {proc.pid=}.")\r\n    proc.terminate(); proc.wait()\r\n    atexit.unregister(proc.terminate)\r\n    return proc._args, proc._kwargs\r\n\r\ndef restart_py(proc: subprocess.Popen = None, opid=PID) -> subprocess.Popen:\r\n    if proc and proc.poll() is None: \r\n        args, kwargs = stop_py(proc)\r\n        kwargs[\'opid\'] = opid\r\n    else: args, kwargs = [], {}\r\n    return start_py(\'qaczar.py\', *args, **kwargs)\r\n\r\ndef watch_over(proc: subprocess.Popen, fn: str) -> t.NoReturn:  \r\n    assert isinstance(proc, subprocess.Popen)\r\n    source, old_mtime, stable = read_file(fn), mtime_file(fn), True\r\n    while True:\r\n        time.sleep(2.6)\r\n        if (new_mtime := mtime_file(fn)) != old_mtime:\r\n            mutation, old_mtime = read_file(fn), new_mtime\r\n            if mutation != source:\r\n                emit(f"Mutation detected. Optimistic restart.")\r\n                proc, stable = restart_py(proc), True\r\n            continue\r\n        if proc.poll() is not None:  # Script terminated.\r\n            if proc.returncode == 0: sys.exit(0)  # Halt from below.\r\n            if stable:\r\n                emit(f"Script died {proc.returncode=}. Restart and mark unstable.")\r\n                proc, stable = restart_py(proc), False\r\n                continue\r\n            halt(f"Script died twice. Stopping watcher.")\r\n        if not stable:\r\n            emit(f"Stabilizing {proc.pid=}.")\r\n            source, stable = read_file(fn), True\r\n            \r\n\r\n#@# CONTENT GENERATOR\r\n\r\nimport io\r\nimport contextlib\r\n\r\nWORKDIR = os.path.join(os.path.dirname(\'qaczar.py\'), \'.work\')\r\nTEMPLATES = {}\r\n\r\ndef set_workdir(role: str) -> None:\r\n    global WORKDIR\r\n    WORKDIR = os.path.join(os.path.dirname(\'qaczar.py\'), f\'.{role}\')\r\n\r\ndef work_path(fname: str) -> str:\r\n    global WORKDIR\r\n    if not os.path.isdir(WORKDIR): os.mkdir(WORKDIR)\r\n    return os.path.join(WORKDIR, fname)\r\n\r\ndef load_template(fname: str) -> str:\r\n    global TEMPLATES\r\n    if (last := mtime_file(fname)) != TEMPLATES.get(fname, (None, None))[1]:\r\n        emit(f"Loading template {fname=}.")\r\n        mt = pip_import(\'mako.template\')\r\n        tpl = mt.Template(filename=fname)\r\n        TEMPLATES[fname] = tpl, last\r\n        return tpl\r\n    return TEMPLATES[fname][0]\r\n\r\ndef build_form():\r\n    # TODO: New function to automatically create a form from a function.\r\n    pass\r\n\r\ndef process_html(fname: str, context: dict) -> str:\r\n    template = load_template(fname)\r\n    content = template.render(**globals(), **context)\r\n    write_file(wp := work_path(fname), content, encoding=\'utf-8\')\r\n    emit(f"Written to {wp=} as {fname=} ({len(content)=} bytes).")  \r\n    return wp\r\n\r\ndef process_py(fname: str, context: dict) -> str:\r\n    # GET returns a fragment of the code.\r\n    # POST executes the code passing the form data as arguments.\r\n    if context[\'method\'] == \'GET\':\r\n        if query := context[\'query\']: \r\n            code = extract_code(fname, **query)\r\n        else: code = read_file(fname)\r\n        write_file(wp := work_path(fname), code, encoding=\'utf-8\')\r\n        emit(f"Written to {wp=} as {fname=} ({len(code)=} bytes).")\r\n        return wp\r\n    if context[\'method\'] == \'POST\':\r\n        code = read_file(fname)\r\n        emit(f"Executing {fname=} with {context[\'data\']=}.")\r\n        # Capture the output and write to a work file.\r\n        with contextlib.redirect_stdout(io.StringIO()) as out:\r\n            exec(code, globals(), context[\'data\'])\r\n        write_file(wp := work_path(fname), out.getvalue(), encoding=\'utf-8\')\r\n        emit(f"Written to {wp=} as {fname=} ({len(out.getvalue())=} bytes).")\r\n        return wp\r\n    \r\n@timed\r\ndef dispatch_processor(fname: str, context: dict) -> str | None:\r\n    if (processor := globals().get(f\'process_{fname.split(".")[-1]}\')):\r\n        emit(f"Processing {fname=} with <{processor.__name__}>.")\r\n        return processor(fname, context)\r\n    return None\r\n\r\n\r\n#@# SECURE SERVER\r\n\r\nimport ssl\r\nimport importlib\r\nimport datetime as dt\r\nimport http.server as hs\r\nimport socketserver as ss\r\nimport urllib.parse as parse\r\n\r\nHOST, PORT, SITE = \'localhost\', 9443, \'qaczar.com\'\r\n\r\n@imports(\'cryptography.x509\',\r\n    \'cryptography.hazmat.primitives.asymmetric.rsa\',\r\n    \'cryptography.hazmat.primitives.hashes\',\r\n    \'cryptography.hazmat.primitives.serialization\')\r\ndef get_ssl_certs(x509, rsa, hashes, ser, site=HOST) -> tuple[str, str]:\r\n    # x509 has to be imported first, or serialization will be missing dependencies.\r\n    if not os.path.exists(\'.ssl\'): os.mkdir(\'.ssl\')\r\n    certname, keyname = \'.ssl/cert.pem\', \'.ssl/key.pem\'\r\n    if os.path.exists(certname) and os.path.exists(keyname):\r\n        cert = x509.load_pem_x509_certificate(read_file(certname))\r\n        if cert.not_valid_after > dt.datetime.utcnow(): return certname, keyname\r\n        else: os.remove(certname); os.remove(keyname)\r\n    emit("Generating new SSL certificates for localhost.")\r\n    key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\r\n    write_file(keyname, key.private_bytes(\r\n            encoding=ser.Encoding.PEM,\r\n            format=ser.PrivateFormat.PKCS8,\r\n            encryption_algorithm=ser.NoEncryption()))\r\n    name = x509.Name([x509.NameAttribute(x509.NameOID.COMMON_NAME, site)])\r\n    cert = x509.CertificateBuilder() \\\r\n            .subject_name(name) \\\r\n            .issuer_name(name) \\\r\n            .public_key(key.public_key()) \\\r\n            .serial_number(x509.random_serial_number()) \\\r\n            .not_valid_before(dt.datetime.utcnow()) \\\r\n            .not_valid_after(dt.datetime.utcnow() + dt.timedelta(days=3)) \\\r\n            .add_extension(x509.SubjectAlternativeName([x509.DNSName(site)]), critical=False) \\\r\n            .add_extension(x509.BasicConstraints(ca=False, path_length=None), critical=True) \\\r\n            .sign(key, hashes.SHA256())\r\n    write_file(certname, cert.public_bytes(ser.Encoding.PEM))\r\n    return certname, keyname\r\n\r\ndef build_https_server() -> tuple:\r\n    ssl_ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\r\n    ssl_ctx.load_cert_chain(*get_ssl_certs())\r\n    \r\n    class SSLServer(ss.TCPServer):\r\n        def __init__(self, server_address, RequestHandlerClass, bind_and_activate=True):\r\n            ss.TCPServer.__init__(self, server_address, RequestHandlerClass, bind_and_activate)\r\n            self.socket = ssl_ctx.wrap_socket(self.socket, server_side=True) \r\n\r\n    class EmitHandler(hs.SimpleHTTPRequestHandler):\r\n        def log_message(self, format, *args):\r\n            emit(f"Access from {self.address_string()} {format % args}")\r\n\r\n        @property\r\n        def content_length(self) -> int:\r\n            return int(self.headers.get(\'content-length\', 0))\r\n        \r\n        def rfile_read(self, encoding: str = \'utf-8\') -> bytes:\r\n            return self.rfile.read(self.content_length).decode(encoding)\r\n\r\n        def build_context(self, path:str, method: str = None) -> dict:\r\n            if \'?\' not in path: qs = \'\'\r\n            else: path, qs = path.split(\'?\', 1)\r\n            context = {\'ip\': self.client_address[0], \'ts\': iso8601(), \'method\': method}\r\n            context[\'query\'] = parse.parse_qs(qs)\r\n            if method == \'POST\': context[\'form\'] = parse.parse_qs(self.rfile_read())\r\n            else: context[\'form\'] = {}\r\n            return context\r\n\r\n        def build_response(self, method: str = None) -> bool:\r\n            self.path = \'/qaczar.html\' if self.path == \'/\' else self.path\r\n            context = self.build_context(self.path, method)\r\n            self.work_path = dispatch_processor(self.path[1:], context)\r\n            emit(f"{context[\'ip\']} {context[\'ts\']} {method} {self.path} ({self.work_path})")\r\n            \r\n        def translate_path(self, path: str = None) -> str:\r\n            return super().translate_path(path) if not self.work_path else self.work_path\r\n\r\n        def do_HEAD(self) -> None:\r\n            self.build_response(\'HEAD\'); return super().do_HEAD()\r\n            \r\n        def do_GET(self) -> None:\r\n            self.build_response(\'GET\'); return super().do_GET()\r\n        \r\n        def do_POST(self) -> None:\r\n            self.build_response(\'POST\'); return super().do_GET()\r\n\r\n    return SSLServer, EmitHandler\r\n\r\n\r\n#@#  SELF TESTING\r\n\r\n@imports(\'urllib3\')\r\ndef test_server(urllib3, *args, **kwargs) -> t.NoReturn:\r\n    http = urllib3.PoolManager(\r\n        cert_reqs=\'CERT_REQUIRED\',\r\n        ca_certs=get_ssl_certs()[0])\r\n    \r\n    def server_request(fname:str):\r\n        r = http.request(\'GET\', url := f"https://{HOST}:{PORT}/{fname}", timeout=30)\r\n        emit(f"Server response: {url=} {r=}")\r\n        if r.status != 200: raise ValueError(f"Unexpected response: {r.status} {r.reason}")\r\n        return r.data.decode(\'utf-8\')\r\n    \r\n    assert \'QACZAR\' in server_request(\'qaczar.html\')\r\n    assert \'QACZAR\' in server_request(\'qaczar.py\')\r\n\r\n\r\n#@#  REPOSITORY\r\n\r\ndef commit_source() -> t.NoReturn:\r\n    emit("Commiting source to repository.")\r\n    os.system(\'git add .\')\r\n    os.system(\'git commit -m "auto commit"\')\r\n    os.system(\'git push\')\r\n    emit("Source committed to repository.")\r\n\r\n\r\n#@# COMMON ROLES\r\n\r\ndef watcher_role(*args, next: str = None, **kwargs) -> t.NoReturn:\r\n    if not next: raise ValueError(\'next role was not defined\')\r\n    kwargs[\'role\'] = next\r\n    watch_over(start_py(\'qaczar.py\', *args, **kwargs), \'qaczar.py\')\r\n\r\ndef server_role(*args, host=\'localhost\', port=\'9443\', **kwargs) -> t.NoReturn:\r\n    server_cls, handler_cls = build_https_server()\r\n    with server_cls((host, int(port)), handler_cls) as httpd:\r\n        emit(f"Server ready at https://{host}:{port}")\r\n        atexit.register(httpd.shutdown)\r\n        kwargs[\'role\'] = \'tester\'\r\n        kwargs[\'suite\'] = \'server\' if \'suite\' not in kwargs else kwargs[\'suite\']\r\n        start_py(\'qaczar.py\', *args, **kwargs)\r\n        httpd.serve_forever()\r\n\r\ndef tester_role(*args, suite: str = None, **kwargs) -> t.NoReturn:\r\n    # TODO: Use tests to prevent regressions (loss of functionality)\r\n    emit(f"Running tests for {suite}.")\r\n    for test in globals().keys():\r\n        if test == f\'test_{suite}\': \r\n            emit(f"Running {test=}...")\r\n            globals()[test](*args, **kwargs)\r\n    emit(f"Tests for {suite} passed.")\r\n    commit_source()\r\n\r\n\r\ndef deployer_role(*args, **kwargs) -> t.NoReturn:\r\n    pass\r\n\r\n\r\n\r\n#@# DISPATCHER\r\n\r\ndef role_dispatcher(role: str, args: tuple, kwargs: dict) -> None:\r\n    import threading\r\n    set_workdir(role)\r\n    opid = kwargs.pop(\'opid\', None)  # If we receive opid it means we are being watched.\r\n    emit(f"Assuming role=\'{__role}\' args={__args} kwargs={__kwargs} watch by {opid=}.")\r\n    def dispatch():\r\n        function = globals().get(f"{role}_role")\r\n        if function is None: raise ValueError(f"Role \'{role}\' is not defined.")\r\n        function(*args, **kwargs)\r\n    threading.Thread(target=dispatch, daemon=True).start()\r\n    # We can do other stuff here, like launching another role.\r\n    while threading.active_count() > 1: time.sleep(1)\r\n\r\nif __name__ == "__main__":\r\n    if len(sys.argv) == 1:\r\n        __role, __args, __kwargs = \'watcher\', [], {\'next\': \'server\'}\r\n        reset = True\r\n    else:\r\n        __args, __kwargs = split_arg_line(sys.argv[1:])\r\n        __role = __kwargs.pop(\'role\')  # It\'s ok to fail if role is not defined.\r\n        reset = False\r\n    setup_environ(reset=reset)\r\n    DEBUG = True if \'debug\' in __args else DEBUG\r\n    role_dispatcher(__role, __args, __kwargs)\r\n'